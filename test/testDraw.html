<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.87.1/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.87.1/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>
<body>

<div id="cesiumContainer" class="fullSize"></div>
<div id="loadingOverlay"><h1>Loading...</h1></div>
<div id="toolbar">
    <table class="infoPanel">
        <tbody>
        <tr>
            <td>Left click to add a vertex.</td>
        </tr>
        <tr>
            <td>Right click to start new shape.</td>
        </tr>
        </tbody>
    </table>
</div>

<script>
  var viewer = new Cesium.Viewer("cesiumContainer", {
    selectionIndicator: false,
    infoBox: false,
    terrainProvider: Cesium.createWorldTerrain(),
  });

  if (!viewer.scene.pickPositionSupported) {
    window.alert("This browser does not support pickPosition.");
  }

  viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(
    Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK
  );

  function createPoint(worldPosition) {
    var point = viewer.entities.add({
      position: worldPosition,
      point: {
        color: Cesium.Color.WHITE,
        pixelSize: 5,
        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
      },
    });
    return point;
  }

  var drawingMode = "polygon";

  function drawShape(positionData) {
    var shape;
    if (drawingMode === "line") {
      shape = viewer.entities.add({
        polyline: {
          positions: positionData,
          clampToGround: true,
          width: 3,
        },
      });
    } else if (drawingMode === "polygon") {
      shape = viewer.entities.add({
        polygon: {
          hierarchy: positionData,
          material: new Cesium.ColorMaterialProperty(
            Cesium.Color.WHITE.withAlpha(0.7)
          ),
        },
      });
    }
    return shape;
  }

  let activeShapePoints = [];
  let activeShape;
  let floatingPoint;
  let pointsOrigin = [];
  let handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
  handler.setInputAction(function (event) {
    // We use `viewer.scene.pickPosition` here instead of `viewer.camera.pickEllipsoid` so that
    // we get the correct point when mousing over terrain.
    let earthPosition = viewer.scene.pickPosition(event.position);
    pointsOrigin.push(new Cesium.Cartesian3(earthPosition.x, earthPosition.y, earthPosition.z))
    console.log('点击地点', earthPosition)
    console.log('点击地点', viewer.scene.globe.ellipsoid.cartesianToCartographic(earthPosition))
    // `earthPosition` will be undefined if our mouse is not over the globe.
    if (Cesium.defined(earthPosition)) {
      if (activeShapePoints.length === 0) {
        floatingPoint = createPoint(earthPosition);
        activeShapePoints.push(earthPosition);
        let dynamicPositions = new Cesium.CallbackProperty(function () {
          if (drawingMode === "polygon") {
            return new Cesium.PolygonHierarchy(activeShapePoints);
          }
          return activeShapePoints;
        }, false);
        activeShape = drawShape(dynamicPositions);
      }
      activeShapePoints.push(earthPosition);
      createPoint(earthPosition);
    }
  }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

  // 移动
  handler.setInputAction(function (event) {
    if (Cesium.defined(floatingPoint)) {
      var newPosition = viewer.scene.pickPosition(event.endPosition);
      if (Cesium.defined(newPosition)) {
        floatingPoint.position.setValue(newPosition);
        activeShapePoints.pop();
        activeShapePoints.push(newPosition);
      }
    }
  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

  // Redraw the shape so it's not dynamic and remove the dynamic shape.
  function terminateShape() {
    console.log('绘制点', JSON.parse(JSON.stringify(activeShapePoints)));
    activeShapePoints.pop();
    drawShape(activeShapePoints);
    console.log('绘制点', activeShapePoints);
    console.log('开挖');
    clipping(activeShapePoints);


    viewer.entities.remove(floatingPoint);
    viewer.entities.remove(activeShape);
    floatingPoint = undefined;
    activeShape = undefined;
    activeShapePoints = [];
  }


  handler.setInputAction(function (event) {
    terminateShape();
  }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

  var options = [
    {
      text: "Draw Lines",
      onselect: function () {
        if (!Cesium.Entity.supportsPolylinesOnTerrain(viewer.scene)) {
          window.alert(
            "This browser does not support polylines on terrain."
          );
        }

        terminateShape();
        drawingMode = "line";
      },
    },
    {
      text: "Draw Polygons",
      onselect: function () {
        terminateShape();
        drawingMode = "polygon";
      },
    },
  ];

  // Sandcastle.addToolbarMenu(options);
  // Zoom in to an area with mountains
  viewer.camera.lookAt(
    Cesium.Cartesian3.fromDegrees(-122.2058, 46.1955, 1000.0),
    new Cesium.Cartesian3(5000.0, 5000.0, 5000.0)
  );
  viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);

  // 挖掘
  function clipping(points) {
    // var points = [
    //   Cesium.Cartesian3.fromDegrees(116.5, 40.8),
    //   Cesium.Cartesian3.fromDegrees(116.9, 40.8),
    //   Cesium.Cartesian3.fromDegrees(116.9, 41.5)
    // ];
    console.log('点集合', points)
    console.log('初始点集合', pointsOrigin)
    var pointsLength = points.length;
    var clippingPlanes = []; // 存储ClippingPlane集合
    for (var i = 0; i < pointsLength; ++i) {
      let nextIndex = (i + 1) % pointsLength;
      let midpoint = Cesium.Cartesian3.add(points[i], points[nextIndex], new Cesium.Cartesian3());
      midpoint = Cesium.Cartesian3.multiplyByScalar(midpoint, 0.5, midpoint);

      let up = Cesium.Cartesian3.normalize(midpoint, new Cesium.Cartesian3());
      let right = Cesium.Cartesian3.subtract(points[nextIndex], midpoint, new Cesium.Cartesian3());
      right = Cesium.Cartesian3.normalize(right, right);

      let normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
      normal = Cesium.Cartesian3.normalize(normal, normal);
      let originCenteredPlane = new Cesium.Plane(normal, 0.0);
      let distance = Cesium.Plane.getPointDistance(originCenteredPlane, midpoint);

      clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));
    }

    viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
      planes: clippingPlanes,
      edgeWidth: 2.0,
      edgeColor: Cesium.Color.YELLOW,
    });

    let ellipsoid = viewer.scene.globe.ellipsoid;
    let carts = pointsOrigin.map(x => ellipsoid.cartesianToCartographic(x));
    let pointsCarts = []
    for (const pointsCart of carts) {
      pointsCarts.push(Cesium.Math.toDegrees(pointsCart.longitude))
      pointsCarts.push(Cesium.Math.toDegrees(pointsCart.latitude))
      pointsCarts.push(pointsCart.height)
    }

    // console.log('添加坑', pointsCarts);
    // viewer.entities.add({
    //   polygon: {
    //     hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights(pointsCarts),
    //     material: new Cesium.ImageMaterialProperty({
    //       image: "./1.jpg"
    //     }),
    //     extrudedHeight: 0,
    //     perPositionHeight: true,
    //     closeTop: false,
    //     closeBottom: true,
    //   }
    // });
  }


  function createBottomSurface(tempPoints) {
    console.log("***********createBottomSurface()点坐标****************" + tempPoints[0].lon + tempPoints[0].lat + tempPoints[0].hei);
    //获得裁剪处最低点坐标高度
    var minHeight = getMinHeight(tempPoints).minHeight;
    console.log("*************createBottomSurface()的最低点**************" + minHeight);
    //将存储坐标点push进bottomPos数组
    let bottomPos = []
    for (var i = 0; i < tempPoints.length; i++) {
      bottomPos.push(tempPoints[i].lon)
      bottomPos.push(tempPoints[i].lat)
      bottomPos.push(minHeight - depth)
    }
    console.log("**********************createBottomSurface()底部坐标：***************************" + bottomPos);
    //添加底面贴图
    var polygon = new Cesium.PolygonGeometry({
      polygonHierarchy: new Cesium.PolygonHierarchy(
        Cesium.Cartesian3.fromDegreesArrayHeights(bottomPos)
      ),
      perPositionHeight: true
    })
    const geometry = Cesium.PolygonGeometry.createGeometry(polygon)
    const material = new Cesium.Material({
      fabric: {
        type: 'Image',
        uniforms: {
          image: '../../static/Images/bottomImg.jpg'
        }
      }
    })
    const appearance = new Cesium.MaterialAppearance({
      translucent: false,
      flat: true,
      material
    })
    viewer.scene.primitives.add(new Cesium.Primitive({
        geometryInstances: new Cesium.GeometryInstance({
          geometry
        }),
        appearance,
        asynchronous: false
      })
    )
  }


</script>
</body>
</html>